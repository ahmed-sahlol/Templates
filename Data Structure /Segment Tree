struct Node {
    int val;

    Node() {
        val = 0;
    }

    Node(int x) {
        val = x;
    }

    void change(int x) {
        val = x;
    }
};

struct sagara {
    vector<Node> segdata;
    int tree_size;

    sagara(int n) {
        tree_size = 1;
        while (tree_size < n) tree_size *= 2;
        segdata.assign(2 * tree_size, Node());
    }

    Node merge(Node &lf, Node &ri) {
        Node ans = Node();
        ans.val = lf.val + ri.val;
        return ans;
    }

    Node query(int l, int r, int ni, int lx, int rx) {
        if (l >= rx || lx >= r) return Node();
        if (lx >= l && r >= rx) return segdata[ni];
        int mid = (lx + rx) / 2;
        Node lf = query(l, r, 2 * ni + 1, lx, mid);
        Node ri = query(l, r, 2 * ni + 2, mid, rx);
        return merge(lf, ri);
    }

    Node query(int l, int r) {
        return query(l, r, 0, 0, tree_size);
    }

    void set(int idx, int val, int ni, int lx, int rx) {
        if (rx - lx == 1) {
            segdata[ni].change(val);
            return;
        }
        int mid = (lx + rx) / 2;
        if (idx >= mid) set(idx, val, 2 * ni + 2, mid, rx);
        else set(idx, val, 2 * ni + 1, lx, mid);
        segdata[ni] = merge(segdata[2 * ni + 1], segdata[2 * ni + 2]);
    }

    void set(int idx, int val) {
        set(idx, val, 0, 0, tree_size);
    }

    void init(vector<int> &arr, int ni, int lx, int rx) {
        if (rx - lx == 1) {
            if (lx < arr.size())segdata[ni] = Node(arr[lx]);
            return;
        }
        int mid = (rx + lx) >> 1;
        init(arr, 2 * ni + 1, lx, mid);
        init(arr, 2 * ni + 2, mid, rx);
        segdata[ni] = merge(segdata[2 * ni + 1], segdata[2 * ni + 2]);
    }

    void init(vector<int> &arr) {
        init(arr, 0, 0, tree_size);
    }
};
