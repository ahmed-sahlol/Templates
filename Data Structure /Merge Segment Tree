struct Node {
    vector<int> v;

    Node() {
        v = {};
    }

    Node(int x) {
        v = {x};
    }
};

struct sagara {
    vector<Node> segdata;
    int tree_size;

    sagara(int n) {
        tree_size = 1;
        while (tree_size < n) tree_size *= 2;
        segdata.assign(2 * tree_size, Node());
    }

    Node merge(Node &lf, Node &ri) {
        Node ans = Node();

        int idx1 = 0, idx2 = 0, sz1 = lf.v.size(), sz2 = ri.v.size();

        while (idx1 < sz1 && idx2 < sz2) {
            if (lf.v[idx1] < ri.v[idx2]) ans.v.push_back(lf.v[idx1++]);
            else ans.v.push_back(ri.v[idx2++]);
        }

        while (idx1 < sz1) { ans.v.push_back(lf.v[idx1]), idx1++; }

        while (idx2 < sz2) { ans.v.push_back(ri.v[idx2]), idx2++; }

        return ans;
    }

    Node query(int l, int r, int ni, int lx, int rx) {
        if (l >= rx || lx >= r) return Node();
        if (lx >= l && r >= rx) return segdata[ni];
        int mid = (lx + rx) / 2;
        Node lf = query(l, r, 2 * ni + 1, lx, mid);
        Node ri = query(l, r, 2 * ni + 2, mid, rx);
        return merge(lf, ri);
    }

    Node query(int l, int r) { return query(l, r, 0, 0, tree_size); }

    void init(vector<int> &arr, int ni, int lx, int rx) {
        if (rx - lx == 1) {
            if (lx < arr.size()) segdata[ni] = Node(arr[lx]);
            return;
        }
        int mid = (rx + lx) >> 1;
        init(arr, 2 * ni + 1, lx, mid);
        init(arr, 2 * ni + 2, mid, rx);
        segdata[ni] = merge(segdata[2 * ni + 1], segdata[2 * ni + 2]);
    }

    void init(vector<int> &arr) { init(arr, 0, 0, tree_size); }
};
